<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MLOps Security: Workload Identity Federation vs Service Account Keys - Sonika Janagill</title>
    <meta name="description" content="MLOps security guide: Discover why service account keys and cloud secrets are security nightmares. Learn how Workload Identity Federation eliminates static credentials for multi-cloud authentication on Google Cloud.">
    <meta name="author" content="Sonika Janagill">
    <meta name="keywords" content="Workload Identity Federation, MLOps security, cloud credentials, cloud secrets, multi-cloud authentication, service account keys, GCP security, Google Cloud, credential management, zero-trust architecture">

    <!-- Open Graph -->
    <meta property="og:type" content="article">
    <meta property="og:title" content="Why Static Credentials Are Your MLOps Security Catastrophe (And How to Fix It)">
    <meta property="og:description" content="Static credentials cost you money, time, and security. Learn how Workload Identity Federation eliminates secrets entirely through cryptographic trust.">
    <meta property="og:url" content="https://sonikajanagill.com/articles/static-credentials-mlops-security/">
    
    <!-- Canonical Link -->
    <link rel="canonical" href="https://sonikajanagill.com/articles/static-credentials-mlops-security/">

    <!-- Security Headers -->
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
    <meta name="referrer" content="strict-origin-when-cross-origin">

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="../../img/Sonika_Salmon.jpeg">

    <!-- Styles -->
    <link rel="stylesheet" href="../../styles.css">
    <link rel="stylesheet" href="../article-styles.css">
</head>
<body>
    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="/" class="nav-logo">
                <img src="../../img/Sonika-Logo-Light.jpeg" alt="Sonika Janagill" class="logo-light">
                <img src="../../img/Sonika-Logo-Dark.jpeg" alt="Sonika Janagill" class="logo-dark">
                <span class="nav-home-text">Home</span>
            </a>
            <ul class="nav-links">
                <li><a href="/about.html">About</a></li>
                <li><a href="/articles/">Articles</a></li>
                <li><a href="/contact.html">Contact</a></li>
                <li>
                    <button class="theme-toggle" id="theme-toggle" aria-label="Toggle dark mode">
                        <img src="../../img/Sun.png" alt="Light mode" class="theme-icon theme-icon-light">
                        <img src="../../img/Moon.png" alt="Dark mode" class="theme-icon theme-icon-dark">
                    </button>
                </li>
            </ul>
        </div>
    </nav>

    <!-- Blog Header -->
    <header class="blog-header">
        <div class="container">
            <div class="blog-header-left">
                <div class="blog-header-tags">
                    <a href="/articles/?tag=MLOps" class="blog-header-tag">#MLOps</a>
                    <a href="/articles/?tag=Security" class="blog-header-tag">#Security</a>
                    <a href="/articles/?tag=GCP" class="blog-header-tag">#GCP</a>
                </div>
                <h2>Enterprise MLOps on GCP</h2>
                <p class="blog-subtitle">Stop Storing Cloud Secrets: How Workload Identity Federation Eliminates Static Keys</p>
                <p><i>The most dangerous part of modern ML isn't model accuracy. It's the secrets we scatter across systems like digital landmines.</i></p>
                
            <div class="blog-header-right">
                <div class="blog-meta">
                    <div class="blog-meta-item">
                        <span>November 2025</span>
                    </div>
                    <div class="blog-meta-item">
                        <span>8 min read</span>
                    </div>
                </div>
                <div class="blog-share-buttons">
                    <a href="https://x.com/intent/tweet?url=https://sonikajanagill.com/articles/static-credentials-mlops-security/" class="blog-share-btn" title="Share on X" target="_blank" rel="noopener noreferrer">
                        <img src="../../img/x-icon.png" alt="X">
                    </a>
                    <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://sonikajanagill.com/articles/static-credentials-mlops-security/" class="blog-share-btn" title="Share on LinkedIn" target="_blank" rel="noopener noreferrer">
                        <img src="../../img/linkedin-icon.png" alt="LinkedIn">
                    </a>
                    <a href="mailto:?subject=Check out this article&body=https://sonikajanagill.com/articles/static-credentials-mlops-security/" class="blog-share-btn" title="Share via Email">
                        <img src="../../img/email-icon.png" alt="Email">
                    </a>
                    <button onclick="copyShareLink(this)" class="blog-share-btn" title="Copy link">
                        <img src="../../img/copy-icon.png" alt="Copy">
                    </button>
                </div>
            </div>
            </div>
        </div>
    </header>

    <div class="article-header-image">
        <img src="../../img/static_credentials_security.png" alt="Why Static Credentials Are Your MLOps Security Catastrophe">
        <p>Image generated using <a href="https://gemini.google.com/">Gemini</a></p>
    </div>

    <!-- Blog Content -->
    <main class="blog-content">
        <a href="../" class="back-link">‚Üê Back to Articles</a>

        <!--<p><em>Series: Enterprise MLOps on GCP (Part 2A)</em></p>-->

        <p class="drop-cap">Recently, a computer science student accidentally committed their Google Cloud service account key to a public GitHub repository. Within hours, malicious bots‚Äîconstantly scanning for exactly this kind of mistake‚Äîdiscovered it and spun up cryptocurrency mining operations. The bill: <strong>$55,000</strong> before the student even woke up (<a href="https://www.reddit.com/r/googlecloud/comments/1noctxi/student_hit_with_a_5544478_google_cloud_bill/">Ref</a>). This is the reality of MLOps security when cloud credentials and cloud secrets are managed through static service account keys instead of modern multi-cloud authentication solutions like Workload Identity Federation.</p>

        <p>But the bill wasn't even the worst part.</p>

        <p>When I first read about this incident, two things struck me:</p>
        <p><strong>First, the attack speed.</strong> Hours, not days. The automation on both sides (malicious bots vs. cloud infrastructure) meant the damage compounded before any human intervention was possible.</p>
        <p><strong>Second, the remediation complexity.</strong> In my implementations across systems, I've seen how credentials proliferate: GitHub Actions variables, AWS Secrets Manager, local dev machines, test containers. When I asked, "Where are all your GCP service account keys?" the answer is always uncertain: "Everywhere."</p>

        <p>The problem is widespread:</p>
        <ul>
            <li>Developers exposed <strong>23.8 million secrets</strong> on public GitHub repositories in 2024 alone‚Äîa significant 25% year-over-year increase from the previous year's figures. (<a href="https://blog.gitguardian.com/the-state-of-secrets-sprawl-2025/">GitGuardian</a>)</li>
            <li><strong>65% of Forbes AI 50 companies</strong> had leaked verified secrets on GitHub (<a href="https://www.wiz.io/blog/forbes-ai-50-leaking-secrets">Wiz Exposure Report 2025</a>)</li>
            <li>Average cost per data breach: <strong>$4.44 million</strong> (<a href="https://uk.newsroom.ibm.com/2025-cost-of-data-breach-UK">IBM Security Report 2025</a>)</li>
        </ul>

        <p>This problem isn't just a technical annoyance; it's a strategic failure. Let's talk about why the traditional approach to multi-cloud access is broken.</p>

        <p><strong>There's a way to eliminate secrets entirely.</strong><br>
        Not hide them.<br>
        Not rotate them.<br>
        <strong>Eliminate them.</strong></p>

        <p>Empowering your team to improve security and operational efficiency. Let me show you what that looks like.</p>

        <h2>The Multi-Cloud Reality: Your Data Lives Everywhere</h2>

        <p>After transitioning from WebSphere Commerce to modern cloud-native ML, I can tell you: the "pure single-cloud" architecture is a fantasy. The reality is messy, organic, and entirely predictable.</p>

        <p><strong>Pattern observed across industry:</strong></p>
        <ul>
            <li><strong>Training Data:</strong> 2TB in AWS S3 (legacy data lake, 10 years old)</li>
            <li><strong>Feature Engineering:</strong> Azure Databricks (acquired the company's infrastructure)</li>
            <li><strong>Model Training:</strong> Vertex AI AutoML (GCP, best-in-class for your use case)</li>
            <li><strong>Inference:</strong> On-premise Kubernetes (latency requirements, regulatory constraints)</li>
        </ul>

        <p>According to Gartner, 92% of enterprises operate in multi-cloud environments. From my implementations, that number feels conservative. The challenge isn't migrating everything to one cloud (unrealistic). The challenge is connecting them securely.</p>

        <p><strong>Migration timeline to single-cloud?</strong> 18+ months, $2M+ in engineering costs.<br>

        <strong>Time to secure this with Workload Identity Federation?</strong> 2 days.</p>

        <p>That's the difference we're talking about.</p>

        <h2>The "Traditional" Approach: A $450K Security Nightmare</h2>

        <p>When faced with this multi-cloud reality, most teams reach for the tool they know: <strong>The Service Account Key.</strong></p>

        <p>I call this the "Download and Pray" pattern. In my WebSphere days, we did something similar with database credentials‚Äîstoring them in WebSphere variables and property files. It was painful then with 20 passwords across an enterprise platform.</p>

        <p>In cloud-native ML? I've watched this pattern multiply by 50.</p>

        <p><strong>Here's what I've observed across every implementation:</strong></p>
        <pre><code>1. ‚úì Create a GCP Service Account.
2. ‚úì Download the JSON key file (the "skeleton key").
3. ‚úì Upload it to AWS Secrets Manager (or worse, a `.env` file).
4. ‚úì Distribute it to 47 microservices via Kubernetes secrets.
5. ‚úì *Try* to remember to rotate it every 90 days.
6. ‚úì Patch CI/CD pipelines when rotation breaks them
7. ‚úì Pray nobody commits the key to GitHub
8. ‚úì Repeat for Azure, GitHub Actions, on-prem...</code></pre>

        <p>This approach isn't just common‚Äîit's nearly universal. I've yet to meet an engineering team that hasn't started here. The question is how quickly they realise it doesn't scale.</p>

        <h3>1. The Financial Cost</h3>

        <p>For a mid-size e-commerce ML project (recommendation engine, 20M users):</p>
        <ul>
            <li><strong>47 service account keys</strong> across AWS, GCP, and Azure</li>
            <li><strong>AWS Secrets Manager cost:</strong> $0.40/secret/month √ó 47 = $18.80/month</li>
            <li><strong>Azure Key Vault cost:</strong> $0.03/10K operations ‚âà $4/month</li>
            <li><strong>Google Secret Manager:</strong> $0.06/secret/month √ó 12 = $0.72/month</li>
            <li><strong>Total storage:</strong> ~$282/year</li>
        </ul>

        <p>That's just storage. The hidden costs:</p>
        <ul>
            <li><strong>Quarterly rotation:</strong> 8 hours √ó 4 = 32 hours/year</li>
            <li><strong>"Expired key" incidents:</strong> 2-3 per quarter, each requiring 4-6 hours</li>
            <li><strong>Total management overhead:</strong> ~60 hours/year per project</li>
        </ul>

        <p>At a $150/hour engineering rate, that's <strong>$9,000/year in management overhead alone</strong>‚Äî33x the storage cost.</p>

        <p>And this was a <em>well-run</em> project. I've seen much worse.</p>

        <h3>2. The Operational Risk</h3>

        <p>Static keys break. The operational risk is real and predictable. In security forums and engineering communities, I regularly see post-mortems following this pattern:</p>
        <ul>
            <li>Production pipeline down 2-6 hours</li>
            <li>Root cause: expired credentials</li>
            <li>Contributing factor: rotation calendar missed, the engineer left the company, the manual process failed</li>
            <li>Impact: revenue loss, customer trust damage, and an emergency all-hands</li>
        </ul>

        <p>During my implementations, preventing these incidents became a primary design goal. The question wasn't "if" rotation would fail, but "when."</p>

        <p>In one of my recent projects using LangChain and RAG in GitHub Actions-to-GCP flows, an expired key halted embedding generation, costing us 4 hours of crunch time. That's why preventing these has become a non-negotiable in my pipelines.</p>

        <h3>3. The Security Liability</h3>

        <p>This is the most critical vulnerability. A static key remains valid until explicitly revoked. If it leaks, it grants access to anyone, anywhere, forever‚Äîand discovering a leak often takes days or weeks. In an era of automated scrapers and AI-driven cyberattacks, relying on a static file is like leaving your front door key under the mat‚Äîand posting your address on the internet.</p>

        <h4>Where Keys Hide (And Leak):</h4>
        <ul>
            <li>üî¥ <strong>GitHub commits</strong> - Even deleted files remain in git history</li>
            <li>üî¥ <strong>CI/CD logs</strong> - Accidentally printed during debug sessions</li>
            <li>üî¥ <strong>Local machines</strong> - 47 developer laptops are 47 attack vectors</li>
            <li>üî¥ <strong>Container images</strong> - Keys baked in during development</li>
            <li>üî¥ <strong>Third-party services</strong> - Logging platforms, monitoring tools</li>
        </ul>

        <p>Each additional location multiplies the attack surface. Each location is a potential breach.</p>

        <p><strong>Workload Identity Federation eliminates all of them.</strong></p>

        <h2>Workload Identity Federation: The Zero-Trust Solution</h2>

        <p>So, if static keys are the problem, what is the solution?</p>

        <p><strong>Stop using them.</strong></p>

        <p>This is where <strong>Workload Identity Federation (WIF)</strong> changes the game. WIF allows you to eliminate static credentials entirely. Instead of saying, "Here is my password" (the key), your workload says, <strong>"I am who AWS says I am‚Äîverify it yourself."</strong></p>

        <h3>Understanding the Shift: A Simple Metaphor</h3>

        <p>Think of it like the difference between:</p>

        <p><strong>Old way (Static Keys):</strong><br>
        Giving someone a physical key to your house that works forever. If they lose it, copy it, or it gets stolen, you're compromised until you change all the locks.</p>

        <p><strong>New way (Workload Identity Federation):</strong><br>
        Having a doorman who checks their ID, calls you to verify, then gives them a temporary pass that expires in an hour. Even if someone steals the pass, it's useless after 60 minutes. No keys to lose, copy, or steal.</p>

        <p><strong>Workload Identity Federation is the doorman.</strong><br>
        Your AWS or Azure environment is the ID.<br>
        The temporary pass is a short-lived token.</p>

        <h3>How It Works: The Conceptual Flow</h3>

        <p>Before we dive into the technical details, here's the high-level concept:</p>

        <p><strong>OLD WAY (Static Keys):</strong></p>
        <pre><code>Your App ‚Üí [JSON Key File stored everywhere] ‚Üí GCP Resources
         (valid forever, 47 copies across systems)</code></pre>

        <p><strong>NEW WAY (WIF):</strong></p>
        <pre><code>Your App ‚Üí [Prove who you are] ‚Üí AWS/Azure verifies ‚Üí GCP grants temporary access
         (no secrets, expires in 1 hour automatically)</code></pre>

        <h3>The Trust Exchange: Technical Implementation</h3>

        <p>Now let's see how this works technically:</p>

        <p></p><pre style="margin: 0; font-size: 12px;"><code>Your AWS Workload
    ‚Üì (1. Who am I?)
AWS Confirms Your Identity
    ‚Üì (2. Here's proof - OIDC token)
Your AWS Workload
    ‚Üì (3. AWS says I'm legit)
GCP Verifies the token
    ‚Üì (4. OK, here's 1-hour access token)
Your AWS Workload
    ‚Üì (5. Do work)
Vertex AI, BigQuery, Storage</code></pre>
        </p>

        <p>Here's the concept in plain English:</p>

        <ol>
            <li><strong>The Request:</strong> Your application running on AWS (using an IAM Role) asks Google Cloud for access.</li>
            <li><strong>The Proof:</strong> It presents a temporary token signed by AWS‚Äîcryptographic proof of its identity.</li>
            <li><strong>The Verification:</strong> Google Cloud's Security Token Service checks this token against a trust policy you defined.</li>
            <li><strong>The Access:</strong> If the trust validates, Google issues a <strong>short-lived access token</strong> (valid for 1 hour) to your application.</li>
        </ol>

        <h3>Detailed Technical Flow</h3>

        <p>For those who want to implement this, here's the complete technical exchange:</p>

        <p></p>
            <pre style="margin: 0; font-size: 12px;"><code>AWS EC2 Instance (IAM Role)
    ‚Üì (1. Request OIDC Token)
AWS STS
    ‚Üì (2. Issue Token signed by AWS)
AWS EC2 Instance (IAM Role)
    ‚Üì (3. Present Token)
GCP Security Token Service
    ‚Üì (4. Verify with WIF Pool/Provider)
Workload Identity Pool
    ‚Üì (5. Validate Trust)
GCP Security Token Service
    ‚Üì (6. Issue Short-lived GCP Token 1hr)
AWS EC2 Instance (IAM Role)
    ‚Üì (7. Access Resources)
Vertex AI, BigQuery, Cloud Storage</code></pre>
            </p>

        <div class="image-placeholder">
            <img src="../../img/WIF.png" alt="Your Unique Value Equation - Your Experience + AI Tools + Underserved Problems = Innovation Opportunity">
        </div>
        <h3>See It In Action</h3>

        <p>If you're more of a visual learner, the Google Cloud team has an excellent 6-minute walkthrough that demonstrates this exact flow. Watch how seamlessly the token exchange happens‚Äîno secrets, no manual rotation, just secure authentication.</p>

        <div class="youtube-embed">
            <iframe 
                src="https://www.youtube.com/embed/4vajaXzHN08" 
                title="Workload Identity Federation Explained - Google Cloud"
                frameborder="0" 
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
                referrerpolicy="strict-origin-when-cross-origin"
                allowfullscreen>
            </iframe>
        </div>

        <p>Now, let's break down why this matters...</p>

        <h3>The Zero-Trust Advantage</h3>

        <p>The shift with WIF is transformative:</p>

        <p><strong>Key Security Properties:</strong></p>
        <ul>
            <li>‚úî <strong>Ephemeral credentials</strong> - Tokens expire automatically in 1 hour (configurable). Even if stolen, they're useless by the time an attacker figures out what they are.</li>
            <li>‚úî <strong>No secrets stored</strong> - Nothing to leak or rotate. There's literally no JSON file to commit to GitHub.</li>
            <li>‚úî <strong>Cryptographic verification</strong> - AWS/Azure signs tokens; GCP verifies cryptographically</li>
            <li>‚úî <strong>Attribute-based access</strong> - Fine-grained control via IAM conditions. You can write policies like <em>"Only allow access if the request comes from this specific AWS role AND this specific production environment."</em></li>
            <li>‚úî <strong>Full audit trail</strong> - Every token exchange logged with complete context</li>
        </ul>

        <h3>Before vs After: The Transformation</h3>

        <table border="1" style="width:100%; border-collapse: collapse; margin: 20px 0;">
            <thead>
                <tr>
                    <th>Aspect</th>
                    <th>Static Keys</th>
                    <th>Workload Identity Federation</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Credential Lifespan</strong></td>
                    <td>Forever (until manually revoked)</td>
                    <td>1 hour (auto-expires)</td>
                </tr>
                <tr>
                    <td><strong>Storage Locations</strong></td>
                    <td>47+ places across clouds</td>
                    <td>Zero (no secrets to store)</td>
                </tr>
                <tr>
                    <td><strong>Rotation Overhead</strong></td>
                    <td>32 hours/year manual work</td>
                    <td>Automatic (0 hours)</td>
                </tr>
                <tr>
                    <td><strong>If Leaked</strong></td>
                    <td>Valid until you discover and revoke</td>
                    <td>Expires in 1 hour anyway</td>
                </tr>
                <tr>
                    <td><strong>Audit Trail</strong></td>
                    <td>Limited visibility</td>
                    <td>Every access logged cryptographically</td>
                </tr>
                <tr>
                    <td><strong>Attack Surface</strong></td>
                    <td>Every storage location is a risk</td>
                    <td>No stored credentials = no attack surface</td>
                </tr>
                <tr>
                    <td><strong>Compliance</strong></td>
                    <td>Manual key management documentation</td>
                    <td>Automated cryptographic audit trail</td>
                </tr>
                <tr>
                    <td><strong>Setup Time</strong></td>
                    <td>15 minutes</td>
                    <td>30 minutes (one-time)</td>
                </tr>
                <tr>
                    <td><strong>Maintenance</strong></td>
                    <td>Ongoing quarterly burden</td>
                    <td>Set it and forget it</td>
                </tr>
            </tbody>
        </table>

        <h2>The Business Case: Why This Matters Now</h2>

        <p>Adopting WIF isn't just "good security hygiene"‚Äîit's a business imperative.</p>

        <h3>Regulatory Pressure is Mounting</h3>

        <p>If you're in a regulated industry, static keys are a compliance red flag. HIPAA, SOC 2 Type II, and GDPR all demand strict access controls and audit trails. WIF provides a cryptographic paper trail for every single access request, making audits trivial instead of terrifying.</p>

        <h3>Google's Official Stance</h3>

        <p>Workload Identity Federation isn't an experimental feature. It's now Google's <strong>recommended pattern</strong> for all multi-cloud workloads. The ecosystem is moving this way; sticking to static keys is choosing to accumulate technical debt.</p>

        <h3>Competitive Velocity</h3>

        <p>Organisations that adopt WIF ship faster. They don't have "key rotation days." They don't have security review bottlenecks for new secrets. They just have automated, secure, invisible authentication that works.</p>

        <p>In my implementations, the teams that adopted WIF freed up an average of <strong>60 hours per quarter</strong> previously spent on credential management. That's 240 hours per year‚Äî6 full engineering weeks‚Äîthat can be redirected to building features instead of fighting infrastructure.</p>

        <h2>When WIF Isn't the Answer</h2>

        <p>For credibility (and because reality is nuanced), let me be clear: Workload Identity Federation isn't always possible.</p>

        <p><strong>Scenarios where you still need service account keys:</strong></p>
        <ul>
            <li><strong>Legacy systems</strong> without OIDC/SAML support (rare, but exist in older enterprise systems)</li>
            <li><strong>Local development</strong> environments (though Application Default Credentials work better here)</li>
            <li><strong>Third-party tools</strong> that require static keys (increasingly uncommon as tooling modernises)</li>
            <li><strong>Offline/disconnected systems</strong> that can't make real-time token exchanges</li>
        </ul>

        <p>For these cases, minimise the 'blast radius': use short-lived keys, strict IAM policies with the principle of least privilege, comprehensive monitoring, and automated rotation. But for 90% of multi-cloud workloads? WIF is the answer.</p>

        <h2>The Promise: From Strategy to Implementation</h2>

        <p>The concept makes sense. The business case is undeniable. You eliminate the risk of a $55,000 crypto-mining bill, and you save your engineers hundreds of hours of drudgery.</p>

        <p><strong>But how do you actually build it?</strong></p>

        <p>How do you configure the AWS IAM roles? How do you map the OIDC tokens? How do you write Terraform? What about troubleshooting when the trust validation fails?</p>

        <p>That's exactly what we'll cover in <strong>Part 2B</strong>.</p>

        <p>In the next article, I'll drop the theory and give you the implementation manual. We'll walk through:</p>

        <ul>
            <li>‚úî <strong>Step-by-step AWS to Vertex AI implementation</strong> (deployable in 15 minutes)</li>
            <li>‚úî <strong>Azure to Vertex AI pattern</strong> specifically for HIPAA-compliant healthcare workloads</li>
            <li>‚úî <strong>Storage Transfer Service pattern</strong> for moving multi-TB datasets without bottlenecks</li>
            <li>‚úî <strong>Complete troubleshooting guide</strong> for when things go wrong (because they will)</li>
            <li>‚úî <strong>Terraform code samples</strong> ready to adapt for your infrastructure</li>
            <li>‚úî <strong>Testing strategies</strong> to validate your WIF configuration before production</li>
        </ul>

        <p><strong>Ready to eliminate your credential nightmares?</strong> Part 2B drops later this week with the complete code and architecture guides.</p>

        <h2>Key Takeaways</h2>

        <p>If you remember nothing else from this article, remember this:</p>

        <ol>
            <li><strong>Static service account keys are a security liability</strong> that costs you money, time, and sleep</li>
            <li><strong>Workload Identity Federation eliminates secrets entirely</strong> through cryptographic trust</li>
            <li><strong>The transformation takes 30 minutes to set up</strong> and saves 60+ hours per quarter</li>
            <li><strong>This is Google's recommended pattern</strong> for multi-cloud workloads‚Äînot an experimental feature</li>
            <li><strong>The implementation details are coming</strong> in Part 2B with complete working code</li>
        </ol>

        <p>Stop downloading keys. Start trusting identity providers.</p>

        <p>Your future self will thank you.</p>

        <p><em>This article is part of the "Enterprise MLOps on GCP" series. Follow me on <a href="https://medium.sonikajanagill.com/" target="_blank" rel="noopener noreferrer">Medium</a> and <a href="https://www.linkedin.com/in/sonikaj/" target="_blank" rel="noopener noreferrer">LinkedIn</a> for Part 2B and the rest of the series.</em></p>

    </main>

    <!-- Footer -->
    <footer>
        <div class="footer-content">
            <p>&copy; 2025 Sonika Janagill. All rights reserved.</p>
            <div class="footer-links">
                <a href="https://www.linkedin.com/in/sonikaj/" target="_blank" rel="noopener noreferrer">LinkedIn</a>
                <a href="https://medium.sonikajanagill.com/" target="_blank" rel="noopener noreferrer">Medium</a>
                <a href="https://github.com/sonikajanagill" target="_blank" rel="noopener noreferrer">GitHub</a>
            </div>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="../article-utils.js"></script>
</body>
</html>
